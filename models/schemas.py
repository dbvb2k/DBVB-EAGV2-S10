"""
Pydantic models for response validation and type safety.

Provides structured validation for LLM responses and internal data structures.
"""
from pydantic import BaseModel, Field, field_validator
from typing import Optional, List, Literal, Dict, Any
from enum import Enum


class StepType(str, Enum):
    """Valid step types."""
    CODE = "CODE"
    CONCLUDE = "CONCLUDE"
    NOP = "NOP"
    NOOP = "NOOP"  # Alias for NOP


class DecisionOutput(BaseModel):
    """
    Validated decision output from LLM.
    
    Represents a decision/plan step generated by the Decision module.
    """
    step_index: int = Field(ge=0, description="Step index number")
    description: str = Field(min_length=1, description="Step description")
    type: StepType = Field(description="Step type")
    code: str = Field(default="", description="Code to execute (if type is CODE)")
    conclusion: str = Field(default="", description="Conclusion text (if type is CONCLUDE)")
    plan_text: List[str] = Field(default_factory=list, description="Full plan text")
    error: Optional[str] = Field(default=None, description="Error message if any")
    raw_text: Optional[str] = Field(default=None, description="Raw LLM response")
    
    @field_validator('type', mode='before')
    @classmethod
    def normalize_step_type(cls, v):
        """Normalize step type to enum."""
        if isinstance(v, str):
            v = v.upper()
            # Handle NOOP alias
            if v == "NOOP":
                v = "NOP"
        return v
    
    @field_validator('plan_text', mode='before')
    @classmethod
    def normalize_plan_text(cls, v):
        """Ensure plan_text is a list."""
        if isinstance(v, str):
            return [v]
        if v is None:
            return []
        return v
    
    def model_post_init(self, __context):
        """Validate step type and content consistency."""
        if self.type == StepType.CODE and not self.code:
            raise ValueError("CODE step type requires non-empty code")
        if self.type == StepType.CONCLUDE and not self.conclusion:
            raise ValueError("CONCLUDE step type requires non-empty conclusion")


class PerceptionOutput(BaseModel):
    """
    Validated perception output from LLM.
    
    Represents perception analysis of input or execution results.
    """
    entities: List[str] = Field(default_factory=list, description="Extracted entities")
    result_requirement: str = Field(default="", description="Result requirement description")
    original_goal_achieved: bool = Field(default=False, description="Whether original goal is achieved")
    reasoning: str = Field(default="", description="Reasoning about goal achievement")
    local_goal_achieved: bool = Field(default=False, description="Whether local/step goal is achieved")
    local_reasoning: str = Field(default="", description="Reasoning about local goal")
    last_tooluse_summary: str = Field(default="", description="Summary of last tool use")
    solution_summary: str = Field(default="", description="Solution summary")
    confidence: str = Field(default="0.0", description="Confidence score (0.0-1.0)")
    error: Optional[str] = Field(default=None, description="Error message if any")
    
    @field_validator('confidence')
    @classmethod
    def validate_confidence(cls, v):
        """Validate and normalize confidence value."""
        try:
            conf_float = float(v)
            # Clamp to [0.0, 1.0]
            conf_float = max(0.0, min(1.0, conf_float))
            return str(conf_float)
        except (ValueError, TypeError):
            return "0.0"
    
    @field_validator('entities')
    @classmethod
    def validate_entities(cls, v):
        """Ensure entities is a list."""
        if not isinstance(v, list):
            return []
        return [str(e) for e in v]
    
    @field_validator('original_goal_achieved', 'local_goal_achieved', mode='before')
    @classmethod
    def normalize_bool(cls, v):
        """Normalize boolean values."""
        if isinstance(v, str):
            return v.lower() in ("true", "1", "yes", "on")
        return bool(v)


class ToolCode(BaseModel):
    """Tool code representation."""
    tool_name: str = Field(min_length=1, description="Tool name")
    tool_arguments: Dict[str, Any] = Field(default_factory=dict, description="Tool arguments")


class StepStatus(str, Enum):
    """Valid step statuses."""
    PENDING = "pending"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"
    CLARIFICATION_NEEDED = "clarification_needed"


class StepModel(BaseModel):
    """
    Validated step model.
    
    Represents a single execution step in the agent loop.
    """
    index: int = Field(ge=0, description="Step index")
    description: str = Field(min_length=1, description="Step description")
    type: StepType = Field(description="Step type")
    code: Optional[ToolCode] = Field(default=None, description="Code to execute")
    conclusion: Optional[str] = Field(default=None, description="Conclusion text")
    execution_result: Optional[Any] = Field(default=None, description="Execution result")
    error: Optional[str] = Field(default=None, description="Error message")
    perception: Optional[PerceptionOutput] = Field(default=None, description="Perception result")
    status: StepStatus = Field(default=StepStatus.PENDING, description="Step status")
    attempts: int = Field(default=0, ge=0, description="Number of attempts")
    was_replanned: bool = Field(default=False, description="Whether step was replanned")
    parent_index: Optional[int] = Field(default=None, ge=0, description="Parent step index if replanned")
    
    @field_validator('code')
    @classmethod
    def validate_code_for_type(cls, v, info):
        """Validate code is present for CODE type steps."""
        step_type = info.data.get('type')
        if step_type == StepType.CODE and v is None:
            raise ValueError("CODE step type requires code")
        return v
    
    @field_validator('conclusion')
    @classmethod
    def validate_conclusion_for_type(cls, v, info):
        """Validate conclusion is present for CONCLUDE type steps."""
        step_type = info.data.get('type')
        if step_type == StepType.CONCLUDE and not v:
            raise ValueError("CONCLUDE step type requires conclusion")
        return v


class SessionState(BaseModel):
    """Validated session state."""
    original_goal_achieved: bool = Field(default=False, description="Whether goal is achieved")
    final_answer: Optional[str] = Field(default=None, description="Final answer")
    confidence: float = Field(default=0.0, ge=0.0, le=1.0, description="Confidence score")
    reasoning_note: str = Field(default="", description="Reasoning note")
    solution_summary: str = Field(default="", description="Solution summary")


class MemoryEntry(BaseModel):
    """Validated memory entry."""
    file: str = Field(min_length=1, description="Source file name")
    query: str = Field(min_length=1, description="Original query")
    result_requirement: str = Field(default="", description="Result requirement")
    solution_summary: str = Field(default="", description="Solution summary")


# Validation functions
def validate_decision_output(data: Dict[str, Any]) -> DecisionOutput:
    """
    Validate and normalize decision output.
    
    Args:
        data: Raw decision output dictionary
        
    Returns:
        Validated DecisionOutput model
        
    Raises:
        ValidationError: If validation fails
    """
    return DecisionOutput(**data)


def validate_perception_output(data: Dict[str, Any]) -> PerceptionOutput:
    """
    Validate and normalize perception output.
    
    Args:
        data: Raw perception output dictionary
        
    Returns:
        Validated PerceptionOutput model
        
    Raises:
        ValidationError: If validation fails
    """
    return PerceptionOutput(**data)


def validate_step(data: Dict[str, Any]) -> StepModel:
    """
    Validate and normalize step data.
    
    Args:
        data: Raw step dictionary
        
    Returns:
        Validated StepModel
        
    Raises:
        ValidationError: If validation fails
    """
    return StepModel(**data)

